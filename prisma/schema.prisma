// Prisma-Konfiguration: aus diesem Schema generiert Prisma den TypeScript-Client
generator client {
  provider = "prisma-client-js"
}

// Datenquelle: PostgreSQL – URLs kommen aus Umgebungsvariablen
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL") // nutzt den direkten 5432-Endpoint (oder notfalls denselben Pooler)
}

// Enum für den Status eines Hottakes (OFFEN/WAHR/FALSCH)
enum HottakeStatus {
  OFFEN
  WAHR
  FALSCH
}

// Kernmodell: ein einzelner Hottake mit Text und Status
model Hottake {
  id        Int            @id @default(autoincrement())
  text      String
  status    HottakeStatus  @default(OFFEN)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  @@map("hottakes")
}

// User mit eindeutigem Nickname (1:n zu Submissions ist hier als 1:1 modelliert)
model User {
  id           Int          @id @default(autoincrement())
  nickname     String       @unique
  email        String?      @unique // Optional vorerst, falls Alt-Daten existieren ohne Email
  passwordHash String?      // Optional für Übergang, aber Pflicht für neue Auth
  resetToken   String?      @unique
  resetTokenExpiry DateTime?
  prefs        Json?        @default("{}") // Für Dark Mode etc. (Phase 9)
  createdAt    DateTime     @default(now())
  submission   Submission?

  @@map("users")
}

// Eine Abgabe (Submission) pro User: enthält die Picks als Integer-Array
model Submission {
  id        Int      @id @default(autoincrement())
  userId    Int      @unique
  user      User     @relation(fields: [userId], references: [id])
  picks     Int[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@map("submissions")
}

// Schlüssel-Wert-Einstellungen, z. B. für Konfigurationen zur Laufzeit
model Setting {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@map("settings")
}

// Optional: Admin-Events für Zeitsteuerung (Start/Lock/Ende) eines Spiels/Ereignisses
model AdminEvent {
  id          Int      @id @default(autoincrement())
  description String
  startTime   DateTime?
  lockTime    DateTime?
  endTime     DateTime?
  activeFlag  Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  @@map("admin_events")
}
